{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { WHITE_SPACE_REGEX } from './regex.generated';\nexport function parseNumberSkeletonFromString(skeleton) {\n  if (skeleton.length === 0) {\n    throw new Error('Number skeleton cannot be empty');\n  } // Parse the skeleton\n\n\n  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function (x) {\n    return x.length > 0;\n  });\n  var tokens = [];\n\n  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {\n    var stringToken = stringTokens_1[_i];\n    var stemAndOptions = stringToken.split('/');\n\n    if (stemAndOptions.length === 0) {\n      throw new Error('Invalid number skeleton');\n    }\n\n    var stem = stemAndOptions[0],\n        options = stemAndOptions.slice(1);\n\n    for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n      var option = options_1[_a];\n\n      if (option.length === 0) {\n        throw new Error('Invalid number skeleton');\n      }\n    }\n\n    tokens.push({\n      stem: stem,\n      options: options\n    });\n  }\n\n  return tokens;\n}\n\nfunction icuUnitToEcma(unit) {\n  return unit.replace(/^(.*?)-/, '');\n}\n\nvar FRACTION_PRECISION_REGEX = /^\\.(?:(0+)(\\*)?|(#+)|(0+)(#+))$/g;\nvar SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\\+|#+)?$/g;\nvar INTEGER_WIDTH_REGEX = /(\\*)(0+)|(#+)(0+)|(0+)/g;\nvar CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;\n\nfunction parseSignificantPrecision(str) {\n  var result = {};\n  str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {\n    // @@@ case\n    if (typeof g2 !== 'string') {\n      result.minimumSignificantDigits = g1.length;\n      result.maximumSignificantDigits = g1.length;\n    } // @@@+ case\n    else if (g2 === '+') {\n      result.minimumSignificantDigits = g1.length;\n    } // .### case\n    else if (g1[0] === '#') {\n      result.maximumSignificantDigits = g1.length;\n    } // .@@## or .@@@ case\n    else {\n      result.minimumSignificantDigits = g1.length;\n      result.maximumSignificantDigits = g1.length + (typeof g2 === 'string' ? g2.length : 0);\n    }\n\n    return '';\n  });\n  return result;\n}\n\nfunction parseSign(str) {\n  switch (str) {\n    case 'sign-auto':\n      return {\n        signDisplay: 'auto'\n      };\n\n    case 'sign-accounting':\n    case '()':\n      return {\n        currencySign: 'accounting'\n      };\n\n    case 'sign-always':\n    case '+!':\n      return {\n        signDisplay: 'always'\n      };\n\n    case 'sign-accounting-always':\n    case '()!':\n      return {\n        signDisplay: 'always',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-except-zero':\n    case '+?':\n      return {\n        signDisplay: 'exceptZero'\n      };\n\n    case 'sign-accounting-except-zero':\n    case '()?':\n      return {\n        signDisplay: 'exceptZero',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-never':\n    case '+_':\n      return {\n        signDisplay: 'never'\n      };\n  }\n}\n\nfunction parseConciseScientificAndEngineeringStem(stem) {\n  // Engineering\n  var result;\n\n  if (stem[0] === 'E' && stem[1] === 'E') {\n    result = {\n      notation: 'engineering'\n    };\n    stem = stem.slice(2);\n  } else if (stem[0] === 'E') {\n    result = {\n      notation: 'scientific'\n    };\n    stem = stem.slice(1);\n  }\n\n  if (result) {\n    var signDisplay = stem.slice(0, 2);\n\n    if (signDisplay === '+!') {\n      result.signDisplay = 'always';\n      stem = stem.slice(2);\n    } else if (signDisplay === '+?') {\n      result.signDisplay = 'exceptZero';\n      stem = stem.slice(2);\n    }\n\n    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {\n      throw new Error('Malformed concise eng/scientific notation');\n    }\n\n    result.minimumIntegerDigits = stem.length;\n  }\n\n  return result;\n}\n\nfunction parseNotationOptions(opt) {\n  var result = {};\n  var signOpts = parseSign(opt);\n\n  if (signOpts) {\n    return signOpts;\n  }\n\n  return result;\n}\n/**\r\n * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options\r\n */\n\n\nexport function parseNumberSkeleton(tokens) {\n  var result = {};\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    switch (token.stem) {\n      case 'percent':\n      case '%':\n        result.style = 'percent';\n        continue;\n\n      case '%x100':\n        result.style = 'percent';\n        result.scale = 100;\n        continue;\n\n      case 'currency':\n        result.style = 'currency';\n        result.currency = token.options[0];\n        continue;\n\n      case 'group-off':\n      case ',_':\n        result.useGrouping = false;\n        continue;\n\n      case 'precision-integer':\n      case '.':\n        result.maximumFractionDigits = 0;\n        continue;\n\n      case 'measure-unit':\n      case 'unit':\n        result.style = 'unit';\n        result.unit = icuUnitToEcma(token.options[0]);\n        continue;\n\n      case 'compact-short':\n      case 'K':\n        result.notation = 'compact';\n        result.compactDisplay = 'short';\n        continue;\n\n      case 'compact-long':\n      case 'KK':\n        result.notation = 'compact';\n        result.compactDisplay = 'long';\n        continue;\n\n      case 'scientific':\n        result = __assign(__assign(__assign({}, result), {\n          notation: 'scientific'\n        }), token.options.reduce(function (all, opt) {\n          return __assign(__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'engineering':\n        result = __assign(__assign(__assign({}, result), {\n          notation: 'engineering'\n        }), token.options.reduce(function (all, opt) {\n          return __assign(__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'notation-simple':\n        result.notation = 'standard';\n        continue;\n      // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h\n\n      case 'unit-width-narrow':\n        result.currencyDisplay = 'narrowSymbol';\n        result.unitDisplay = 'narrow';\n        continue;\n\n      case 'unit-width-short':\n        result.currencyDisplay = 'code';\n        result.unitDisplay = 'short';\n        continue;\n\n      case 'unit-width-full-name':\n        result.currencyDisplay = 'name';\n        result.unitDisplay = 'long';\n        continue;\n\n      case 'unit-width-iso-code':\n        result.currencyDisplay = 'symbol';\n        continue;\n\n      case 'scale':\n        result.scale = parseFloat(token.options[0]);\n        continue;\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n      case 'integer-width':\n        if (token.options.length > 1) {\n          throw new RangeError('integer-width stems only accept a single optional option');\n        }\n\n        token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {\n          if (g1) {\n            result.minimumIntegerDigits = g2.length;\n          } else if (g3 && g4) {\n            throw new Error('We currently do not support maximum integer digits');\n          } else if (g5) {\n            throw new Error('We currently do not support exact integer digits');\n          }\n\n          return '';\n        });\n        continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n\n    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {\n      result.minimumIntegerDigits = token.stem.length;\n      continue;\n    }\n\n    if (FRACTION_PRECISION_REGEX.test(token.stem)) {\n      // Precision\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision\n      // precision-integer case\n      if (token.options.length > 1) {\n        throw new RangeError('Fraction-precision stems only accept a single optional option');\n      }\n\n      token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {\n        // .000* case (before ICU67 it was .000+)\n        if (g2 === '*') {\n          result.minimumFractionDigits = g1.length;\n        } // .### case\n        else if (g3 && g3[0] === '#') {\n          result.maximumFractionDigits = g3.length;\n        } // .00## case\n        else if (g4 && g5) {\n          result.minimumFractionDigits = g4.length;\n          result.maximumFractionDigits = g4.length + g5.length;\n        } else {\n          result.minimumFractionDigits = g1.length;\n          result.maximumFractionDigits = g1.length;\n        }\n\n        return '';\n      });\n\n      if (token.options.length) {\n        result = __assign(__assign({}, result), parseSignificantPrecision(token.options[0]));\n      }\n\n      continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision\n\n\n    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {\n      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));\n      continue;\n    }\n\n    var signOpts = parseSign(token.stem);\n\n    if (signOpts) {\n      result = __assign(__assign({}, result), signOpts);\n    }\n\n    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);\n\n    if (conciseScientificAndEngineeringOpts) {\n      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"names":["__assign","WHITE_SPACE_REGEX","parseNumberSkeletonFromString","skeleton","length","Error","stringTokens","split","filter","x","tokens","_i","stringTokens_1","stringToken","stemAndOptions","stem","options","slice","_a","options_1","option","push","icuUnitToEcma","unit","replace","FRACTION_PRECISION_REGEX","SIGNIFICANT_PRECISION_REGEX","INTEGER_WIDTH_REGEX","CONCISE_INTEGER_WIDTH_REGEX","parseSignificantPrecision","str","result","_","g1","g2","minimumSignificantDigits","maximumSignificantDigits","parseSign","signDisplay","currencySign","parseConciseScientificAndEngineeringStem","notation","test","minimumIntegerDigits","parseNotationOptions","opt","signOpts","parseNumberSkeleton","tokens_1","token","style","scale","currency","useGrouping","maximumFractionDigits","compactDisplay","reduce","all","currencyDisplay","unitDisplay","parseFloat","RangeError","g3","g4","g5","minimumFractionDigits","conciseScientificAndEngineeringOpts"],"sources":["C:/suresh/project-two/metiegrow-ui-app/node_modules/@formatjs/icu-skeleton-parser/lib/number.js"],"sourcesContent":["import { __assign } from \"tslib\";\r\nimport { WHITE_SPACE_REGEX } from './regex.generated';\r\nexport function parseNumberSkeletonFromString(skeleton) {\r\n    if (skeleton.length === 0) {\r\n        throw new Error('Number skeleton cannot be empty');\r\n    }\r\n    // Parse the skeleton\r\n    var stringTokens = skeleton\r\n        .split(WHITE_SPACE_REGEX)\r\n        .filter(function (x) { return x.length > 0; });\r\n    var tokens = [];\r\n    for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {\r\n        var stringToken = stringTokens_1[_i];\r\n        var stemAndOptions = stringToken.split('/');\r\n        if (stemAndOptions.length === 0) {\r\n            throw new Error('Invalid number skeleton');\r\n        }\r\n        var stem = stemAndOptions[0], options = stemAndOptions.slice(1);\r\n        for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\r\n            var option = options_1[_a];\r\n            if (option.length === 0) {\r\n                throw new Error('Invalid number skeleton');\r\n            }\r\n        }\r\n        tokens.push({ stem: stem, options: options });\r\n    }\r\n    return tokens;\r\n}\r\nfunction icuUnitToEcma(unit) {\r\n    return unit.replace(/^(.*?)-/, '');\r\n}\r\nvar FRACTION_PRECISION_REGEX = /^\\.(?:(0+)(\\*)?|(#+)|(0+)(#+))$/g;\r\nvar SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\\+|#+)?$/g;\r\nvar INTEGER_WIDTH_REGEX = /(\\*)(0+)|(#+)(0+)|(0+)/g;\r\nvar CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;\r\nfunction parseSignificantPrecision(str) {\r\n    var result = {};\r\n    str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {\r\n        // @@@ case\r\n        if (typeof g2 !== 'string') {\r\n            result.minimumSignificantDigits = g1.length;\r\n            result.maximumSignificantDigits = g1.length;\r\n        }\r\n        // @@@+ case\r\n        else if (g2 === '+') {\r\n            result.minimumSignificantDigits = g1.length;\r\n        }\r\n        // .### case\r\n        else if (g1[0] === '#') {\r\n            result.maximumSignificantDigits = g1.length;\r\n        }\r\n        // .@@## or .@@@ case\r\n        else {\r\n            result.minimumSignificantDigits = g1.length;\r\n            result.maximumSignificantDigits =\r\n                g1.length + (typeof g2 === 'string' ? g2.length : 0);\r\n        }\r\n        return '';\r\n    });\r\n    return result;\r\n}\r\nfunction parseSign(str) {\r\n    switch (str) {\r\n        case 'sign-auto':\r\n            return {\r\n                signDisplay: 'auto',\r\n            };\r\n        case 'sign-accounting':\r\n        case '()':\r\n            return {\r\n                currencySign: 'accounting',\r\n            };\r\n        case 'sign-always':\r\n        case '+!':\r\n            return {\r\n                signDisplay: 'always',\r\n            };\r\n        case 'sign-accounting-always':\r\n        case '()!':\r\n            return {\r\n                signDisplay: 'always',\r\n                currencySign: 'accounting',\r\n            };\r\n        case 'sign-except-zero':\r\n        case '+?':\r\n            return {\r\n                signDisplay: 'exceptZero',\r\n            };\r\n        case 'sign-accounting-except-zero':\r\n        case '()?':\r\n            return {\r\n                signDisplay: 'exceptZero',\r\n                currencySign: 'accounting',\r\n            };\r\n        case 'sign-never':\r\n        case '+_':\r\n            return {\r\n                signDisplay: 'never',\r\n            };\r\n    }\r\n}\r\nfunction parseConciseScientificAndEngineeringStem(stem) {\r\n    // Engineering\r\n    var result;\r\n    if (stem[0] === 'E' && stem[1] === 'E') {\r\n        result = {\r\n            notation: 'engineering',\r\n        };\r\n        stem = stem.slice(2);\r\n    }\r\n    else if (stem[0] === 'E') {\r\n        result = {\r\n            notation: 'scientific',\r\n        };\r\n        stem = stem.slice(1);\r\n    }\r\n    if (result) {\r\n        var signDisplay = stem.slice(0, 2);\r\n        if (signDisplay === '+!') {\r\n            result.signDisplay = 'always';\r\n            stem = stem.slice(2);\r\n        }\r\n        else if (signDisplay === '+?') {\r\n            result.signDisplay = 'exceptZero';\r\n            stem = stem.slice(2);\r\n        }\r\n        if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {\r\n            throw new Error('Malformed concise eng/scientific notation');\r\n        }\r\n        result.minimumIntegerDigits = stem.length;\r\n    }\r\n    return result;\r\n}\r\nfunction parseNotationOptions(opt) {\r\n    var result = {};\r\n    var signOpts = parseSign(opt);\r\n    if (signOpts) {\r\n        return signOpts;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options\r\n */\r\nexport function parseNumberSkeleton(tokens) {\r\n    var result = {};\r\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\r\n        var token = tokens_1[_i];\r\n        switch (token.stem) {\r\n            case 'percent':\r\n            case '%':\r\n                result.style = 'percent';\r\n                continue;\r\n            case '%x100':\r\n                result.style = 'percent';\r\n                result.scale = 100;\r\n                continue;\r\n            case 'currency':\r\n                result.style = 'currency';\r\n                result.currency = token.options[0];\r\n                continue;\r\n            case 'group-off':\r\n            case ',_':\r\n                result.useGrouping = false;\r\n                continue;\r\n            case 'precision-integer':\r\n            case '.':\r\n                result.maximumFractionDigits = 0;\r\n                continue;\r\n            case 'measure-unit':\r\n            case 'unit':\r\n                result.style = 'unit';\r\n                result.unit = icuUnitToEcma(token.options[0]);\r\n                continue;\r\n            case 'compact-short':\r\n            case 'K':\r\n                result.notation = 'compact';\r\n                result.compactDisplay = 'short';\r\n                continue;\r\n            case 'compact-long':\r\n            case 'KK':\r\n                result.notation = 'compact';\r\n                result.compactDisplay = 'long';\r\n                continue;\r\n            case 'scientific':\r\n                result = __assign(__assign(__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));\r\n                continue;\r\n            case 'engineering':\r\n                result = __assign(__assign(__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));\r\n                continue;\r\n            case 'notation-simple':\r\n                result.notation = 'standard';\r\n                continue;\r\n            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h\r\n            case 'unit-width-narrow':\r\n                result.currencyDisplay = 'narrowSymbol';\r\n                result.unitDisplay = 'narrow';\r\n                continue;\r\n            case 'unit-width-short':\r\n                result.currencyDisplay = 'code';\r\n                result.unitDisplay = 'short';\r\n                continue;\r\n            case 'unit-width-full-name':\r\n                result.currencyDisplay = 'name';\r\n                result.unitDisplay = 'long';\r\n                continue;\r\n            case 'unit-width-iso-code':\r\n                result.currencyDisplay = 'symbol';\r\n                continue;\r\n            case 'scale':\r\n                result.scale = parseFloat(token.options[0]);\r\n                continue;\r\n            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\r\n            case 'integer-width':\r\n                if (token.options.length > 1) {\r\n                    throw new RangeError('integer-width stems only accept a single optional option');\r\n                }\r\n                token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {\r\n                    if (g1) {\r\n                        result.minimumIntegerDigits = g2.length;\r\n                    }\r\n                    else if (g3 && g4) {\r\n                        throw new Error('We currently do not support maximum integer digits');\r\n                    }\r\n                    else if (g5) {\r\n                        throw new Error('We currently do not support exact integer digits');\r\n                    }\r\n                    return '';\r\n                });\r\n                continue;\r\n        }\r\n        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\r\n        if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {\r\n            result.minimumIntegerDigits = token.stem.length;\r\n            continue;\r\n        }\r\n        if (FRACTION_PRECISION_REGEX.test(token.stem)) {\r\n            // Precision\r\n            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision\r\n            // precision-integer case\r\n            if (token.options.length > 1) {\r\n                throw new RangeError('Fraction-precision stems only accept a single optional option');\r\n            }\r\n            token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {\r\n                // .000* case (before ICU67 it was .000+)\r\n                if (g2 === '*') {\r\n                    result.minimumFractionDigits = g1.length;\r\n                }\r\n                // .### case\r\n                else if (g3 && g3[0] === '#') {\r\n                    result.maximumFractionDigits = g3.length;\r\n                }\r\n                // .00## case\r\n                else if (g4 && g5) {\r\n                    result.minimumFractionDigits = g4.length;\r\n                    result.maximumFractionDigits = g4.length + g5.length;\r\n                }\r\n                else {\r\n                    result.minimumFractionDigits = g1.length;\r\n                    result.maximumFractionDigits = g1.length;\r\n                }\r\n                return '';\r\n            });\r\n            if (token.options.length) {\r\n                result = __assign(__assign({}, result), parseSignificantPrecision(token.options[0]));\r\n            }\r\n            continue;\r\n        }\r\n        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision\r\n        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {\r\n            result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));\r\n            continue;\r\n        }\r\n        var signOpts = parseSign(token.stem);\r\n        if (signOpts) {\r\n            result = __assign(__assign({}, result), signOpts);\r\n        }\r\n        var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);\r\n        if (conciseScientificAndEngineeringOpts) {\r\n            result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}