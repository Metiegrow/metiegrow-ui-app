{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton } from '@formatjs/icu-skeleton-parser';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\n\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n} // #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\n\n\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n}; // IE11 does not support y and u.\n\nvar REGEX_SUPPORTS_U_AND_Y = true;\n\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\r\n   * legacy Edge or Xbox One browser\r\n   * Unicode flag support: supported\r\n   * Pattern_Syntax support: not supported\r\n   * See https://github.com/formatjs/formatjs/issues/2822\r\n   */\n\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\n\nvar startsWith = hasNativeStartsWith ? // Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} : // For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : // IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n\n  return elements;\n};\nvar fromEntries = // native\nhasNativeFromEntries ? Object.fromEntries : // Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n        k = _a[0],\n        v = _a[1];\n    obj[k] = v;\n  }\n\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ? // Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} : // IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ? // Native\nfunction trimStart(s) {\n  return s.trimStart();\n} : // Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ? // Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} : // Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n}; // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\n\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n} // #endregion\n\n\nvar matchIdentifierAtIndex;\n\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n\n    while (true) {\n      var c = codePointAt(s, index);\n\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n\n    return fromCodePoint.apply(void 0, match);\n  };\n}\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n\n    return this.parseMessage(0, '', false);\n  };\n\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n\n    while (!this.isEOF()) {\n      var char = this.char();\n\n      if (char === 123\n      /* `{` */\n      ) {\n        var result = this.parseArgument(nestingLevel, expectingCloseTag);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else if (char === 125\n      /* `}` */\n      && nestingLevel > 0) {\n        break;\n      } else if (char === 35\n      /* `#` */\n      && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n        if (expectingCloseTag) {\n          break;\n        } else {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      }\n    }\n\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\r\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n   * are accepted:\r\n   *\r\n   * ```\r\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n   * tagName ::= [a-z] (PENChar)*\r\n   * PENChar ::=\r\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n   * ```\r\n   *\r\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n   * since other tag-based engines like React allow it\r\n   */\n\n\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: TYPE.literal,\n          value: \"<\" + tagName + \"/>\",\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n\n      var children = childrenResult.val; // Expecting a close tag\n\n      var endTagStartPosition = this.clonePosition();\n\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n\n        if (tagName !== closingTagName) {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n\n        this.bumpSpace();\n\n        if (!this.bumpIf('>')) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        return {\n          val: {\n            type: TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * This method assumes that the caller has peeked ahead for the first tag character.\r\n   */\n\n\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n\n    return this.message.slice(startOffset, this.offset());\n  };\n\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n\n      break;\n    }\n\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60\n    /* `<` */\n    && (this.ignoreTag || // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n\n      return '<';\n    }\n\n    return null;\n  };\n  /**\r\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n   */\n\n\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39\n    /* `'` */\n    ) {\n      return null;\n    } // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n\n\n    switch (this.peek()) {\n      case 39\n      /* `'` */\n      :\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n\n    this.bump(); // apostrophe\n\n    var codePoints = [this.char()]; // escaped char\n\n    this.bump(); // read chars until the optional closing apostrophe is found\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch === 39\n      /* `'` */\n      ) {\n        if (this.peek() === 39\n        /* `'` */\n        ) {\n          codePoints.push(39); // Bump one more time because we need to skip 2 characters.\n\n          this.bump();\n        } else {\n          // Optional closing apostrophe.\n          this.bump();\n          break;\n        }\n      } else {\n        codePoints.push(ch);\n      }\n\n      this.bump();\n    }\n\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var ch = this.char();\n\n    if (ch === 60\n    /* `<` */\n    || ch === 123\n    /* `{` */\n    || ch === 35\n    /* `#` */\n    && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125\n    /* `}` */\n    && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    if (this.char() === 125\n    /* `}` */\n    ) {\n      this.bump();\n      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    } // argument name\n\n\n    var value = this.parseIdentifierIfPossible().value;\n\n    if (!value) {\n      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125\n      /* `}` */\n      :\n        {\n          this.bump(); // `}`\n\n          return {\n            val: {\n              type: TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n\n      case 44\n      /* `,` */\n      :\n        {\n          this.bump(); // `,`\n\n          this.bumpSpace();\n\n          if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n\n      default:\n        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * Advance the parser until the end of the identifier, if it is currently on\r\n   * an identifier character. Return an empty string otherwise.\r\n   */\n\n\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a; // Parse this range:\n    // {name, type, style}\n    //        ^---^\n\n\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n\n            if (result.err) {\n              return result;\n            }\n\n            var style = trimEnd(result.val);\n\n            if (style.length === 0) {\n              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_1 = createLocation(openingBracePosition, this.clonePosition()); // Extract style or skeleton\n\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n\n              if (result.err) {\n                return result;\n              }\n\n              return {\n                val: {\n                  type: TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n\n              var style = {\n                type: SKELETON_TYPE.dateTime,\n                pattern: skeleton,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}\n              };\n              var type = argType === 'date' ? TYPE.date : TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          } // Regular style or no style.\n\n\n          return {\n            val: {\n              type: argType === 'number' ? TYPE.number : argType === 'date' ? TYPE.date : TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n\n          if (!this.bumpIf(',')) {\n            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n          }\n\n          this.bumpSpace(); // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n\n            if (result.err) {\n              return result;\n            } // Parse another identifier for option parsing\n\n\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n\n          if (argType === 'select') {\n            return {\n              val: {\n                type: TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n\n      default:\n        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125\n    /* `}` */\n    ) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bump(); // `}`\n\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\r\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n   */\n\n\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      switch (ch) {\n        case 39\n        /* `'` */\n        :\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n\n            this.bump();\n            break;\n          }\n\n        case 123\n        /* `{` */\n        :\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n\n        case 125\n        /* `}` */\n        :\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n\n            break;\n          }\n\n        default:\n          this.bump();\n          break;\n      }\n    }\n\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n\n    try {\n      tokens = parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n\n    return {\n      val: {\n        type: SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\r\n   * @param nesting_level The current nesting level of messages.\r\n   *     This can be positive when parsing message fragment in select or plural argument options.\r\n   * @param parent_arg_type The parent argument's type.\r\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n   *     the argument. It is a by-product of a previous parsing attempt.\r\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n   *     the closing tag boundary.\r\n   */\n\n\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n        selectorLocation = parsedFirstIdentifier.location; // Parse:\n    // one {one apple}\n    // ^--^\n\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n\n          if (result.err) {\n            return result;\n          }\n\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      } // Duplicate selector clauses\n\n\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n\n      if (selector === 'other') {\n        hasOtherClause = true;\n      } // Parse:\n      // one {one apple}\n      //     ^----------^\n\n\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]); // Keep track of the existing selectors\n\n      parsedSelectors.add(selector); // Prep next selector clause.\n\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    return {\n      val: options,\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n\n    var hasDigits = false;\n    var decimal = 0;\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch >= 48\n      /* `0` */\n      && ch <= 57\n      /* `9` */\n      ) {\n        hasDigits = true;\n        decimal = decimal * 10 + (ch - 48);\n        this.bump();\n      } else {\n        break;\n      }\n    }\n\n    var location = createLocation(startingPosition, this.clonePosition());\n\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n\n    decimal *= sign;\n\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\r\n   * Return the code point at the current position of the parser.\r\n   * Throws if the index is out of bound.\r\n   */\n\n\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n\n    var code = codePointAt(this.message, offset);\n\n    if (code === undefined) {\n      throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\n    }\n\n    return code;\n  };\n\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n\n\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n\n    var code = this.char();\n\n    if (code === 10\n    /* '\\n' */\n    ) {\n      this.position.line += 1;\n      this.position.column = 1;\n      this.position.offset += 1;\n    } else {\n      this.position.column += 1; // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\r\n   * If the substring starting at the current position of the parser has\r\n   * the given prefix, then bump the parser to the character immediately\r\n   * following the prefix and return true. Otherwise, don't bump the parser\r\n   * and return false.\r\n   */\n\n\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Bump the parser until the pattern character is found and return `true`.\r\n   * Otherwise bump to the end of the file and return `false`.\r\n   */\n\n\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\r\n   * Bump the parser to the target offset.\r\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n   */\n\n\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\n    }\n\n    targetOffset = Math.min(targetOffset, this.message.length);\n\n    while (true) {\n      var offset = this.offset();\n\n      if (offset === targetOffset) {\n        break;\n      }\n\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\n      }\n\n      this.bump();\n\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n\n\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\r\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n   * If the input has been exhausted, then this returns null.\r\n   */\n\n\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\n\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\n\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47;\n  /* '/' */\n}\n/** See `parseTag` function docs. */\n\n\nfunction _isPotentialElementNameChar(c) {\n  return c === 45\n  /* '-' */\n  || c === 46\n  /* '.' */\n  || c >= 48 && c <= 57\n  /* 0..9 */\n  || c === 95\n  /* '_' */\n  || c >= 97 && c <= 122\n  /** a..z */\n  || c >= 65 && c <= 90\n  /* A..Z */\n  || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\n\n\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\n\n\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"names":["_a","__assign","ErrorKind","SKELETON_TYPE","TYPE","SPACE_SEPARATOR_REGEX","parseNumberSkeleton","parseNumberSkeletonFromString","parseDateTimeSkeleton","SPACE_SEPARATOR_START_REGEX","RegExp","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","Object","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","re","RE","exec","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","undefined","first","charCodeAt","second","replace","flag","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","_isWhiteSpace","_isPatternSyntax","push","apply","Parser","message","options","offset","line","column","ignoreTag","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","pound","location","peek","error","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","value","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","number","EXPECT_DATE_TIME_SKELETON","dateTime","pattern","parsedOptions","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"sources":["C:/suresh/project-two/metiegrow-ui-app/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js"],"sourcesContent":["var _a;\r\nimport { __assign } from \"tslib\";\r\nimport { ErrorKind } from './error';\r\nimport { SKELETON_TYPE, TYPE, } from './types';\r\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\r\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton, } from '@formatjs/icu-skeleton-parser';\r\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\r\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\r\nfunction createLocation(start, end) {\r\n    return { start: start, end: end };\r\n}\r\n// #region Ponyfills\r\n// Consolidate these variables up top for easier toggling during debugging\r\nvar hasNativeStartsWith = !!String.prototype.startsWith;\r\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\r\nvar hasNativeFromEntries = !!Object.fromEntries;\r\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\r\nvar hasTrimStart = !!String.prototype.trimStart;\r\nvar hasTrimEnd = !!String.prototype.trimEnd;\r\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\r\nvar isSafeInteger = hasNativeIsSafeInteger\r\n    ? Number.isSafeInteger\r\n    : function (n) {\r\n        return (typeof n === 'number' &&\r\n            isFinite(n) &&\r\n            Math.floor(n) === n &&\r\n            Math.abs(n) <= 0x1fffffffffffff);\r\n    };\r\n// IE11 does not support y and u.\r\nvar REGEX_SUPPORTS_U_AND_Y = true;\r\ntry {\r\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    /**\r\n     * legacy Edge or Xbox One browser\r\n     * Unicode flag support: supported\r\n     * Pattern_Syntax support: not supported\r\n     * See https://github.com/formatjs/formatjs/issues/2822\r\n     */\r\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\r\n}\r\ncatch (_) {\r\n    REGEX_SUPPORTS_U_AND_Y = false;\r\n}\r\nvar startsWith = hasNativeStartsWith\r\n    ? // Native\r\n        function startsWith(s, search, position) {\r\n            return s.startsWith(search, position);\r\n        }\r\n    : // For IE11\r\n        function startsWith(s, search, position) {\r\n            return s.slice(position, position + search.length) === search;\r\n        };\r\nvar fromCodePoint = hasNativeFromCodePoint\r\n    ? String.fromCodePoint\r\n    : // IE11\r\n        function fromCodePoint() {\r\n            var codePoints = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                codePoints[_i] = arguments[_i];\r\n            }\r\n            var elements = '';\r\n            var length = codePoints.length;\r\n            var i = 0;\r\n            var code;\r\n            while (length > i) {\r\n                code = codePoints[i++];\r\n                if (code > 0x10ffff)\r\n                    throw RangeError(code + ' is not a valid code point');\r\n                elements +=\r\n                    code < 0x10000\r\n                        ? String.fromCharCode(code)\r\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\r\n            }\r\n            return elements;\r\n        };\r\nvar fromEntries = \r\n// native\r\nhasNativeFromEntries\r\n    ? Object.fromEntries\r\n    : // Ponyfill\r\n        function fromEntries(entries) {\r\n            var obj = {};\r\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\r\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\r\n                obj[k] = v;\r\n            }\r\n            return obj;\r\n        };\r\nvar codePointAt = hasNativeCodePointAt\r\n    ? // Native\r\n        function codePointAt(s, index) {\r\n            return s.codePointAt(index);\r\n        }\r\n    : // IE 11\r\n        function codePointAt(s, index) {\r\n            var size = s.length;\r\n            if (index < 0 || index >= size) {\r\n                return undefined;\r\n            }\r\n            var first = s.charCodeAt(index);\r\n            var second;\r\n            return first < 0xd800 ||\r\n                first > 0xdbff ||\r\n                index + 1 === size ||\r\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\r\n                second > 0xdfff\r\n                ? first\r\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\r\n        };\r\nvar trimStart = hasTrimStart\r\n    ? // Native\r\n        function trimStart(s) {\r\n            return s.trimStart();\r\n        }\r\n    : // Ponyfill\r\n        function trimStart(s) {\r\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\r\n        };\r\nvar trimEnd = hasTrimEnd\r\n    ? // Native\r\n        function trimEnd(s) {\r\n            return s.trimEnd();\r\n        }\r\n    : // Ponyfill\r\n        function trimEnd(s) {\r\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\r\n        };\r\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\r\nfunction RE(s, flag) {\r\n    return new RegExp(s, flag);\r\n}\r\n// #endregion\r\nvar matchIdentifierAtIndex;\r\nif (REGEX_SUPPORTS_U_AND_Y) {\r\n    // Native\r\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var _a;\r\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\r\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\r\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\r\n    };\r\n}\r\nelse {\r\n    // IE11\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var match = [];\r\n        while (true) {\r\n            var c = codePointAt(s, index);\r\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\r\n                break;\r\n            }\r\n            match.push(c);\r\n            index += c >= 0x10000 ? 2 : 1;\r\n        }\r\n        return fromCodePoint.apply(void 0, match);\r\n    };\r\n}\r\nvar Parser = /** @class */ (function () {\r\n    function Parser(message, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.message = message;\r\n        this.position = { offset: 0, line: 1, column: 1 };\r\n        this.ignoreTag = !!options.ignoreTag;\r\n        this.requiresOtherClause = !!options.requiresOtherClause;\r\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\r\n    }\r\n    Parser.prototype.parse = function () {\r\n        if (this.offset() !== 0) {\r\n            throw Error('parser can only be used once');\r\n        }\r\n        return this.parseMessage(0, '', false);\r\n    };\r\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\r\n        var elements = [];\r\n        while (!this.isEOF()) {\r\n            var char = this.char();\r\n            if (char === 123 /* `{` */) {\r\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\r\n                break;\r\n            }\r\n            else if (char === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\r\n                var position = this.clonePosition();\r\n                this.bump();\r\n                elements.push({\r\n                    type: TYPE.pound,\r\n                    location: createLocation(position, this.clonePosition()),\r\n                });\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                this.peek() === 47 // char code for '/'\r\n            ) {\r\n                if (expectingCloseTag) {\r\n                    break;\r\n                }\r\n                else {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\r\n                }\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                _isAlpha(this.peek() || 0)) {\r\n                var result = this.parseTag(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else {\r\n                var result = this.parseLiteral(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n        }\r\n        return { val: elements, err: null };\r\n    };\r\n    /**\r\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n     * are accepted:\r\n     *\r\n     * ```\r\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n     * tagName ::= [a-z] (PENChar)*\r\n     * PENChar ::=\r\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n     * ```\r\n     *\r\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n     * since other tag-based engines like React allow it\r\n     */\r\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\r\n        var startPosition = this.clonePosition();\r\n        this.bump(); // `<`\r\n        var tagName = this.parseTagName();\r\n        this.bumpSpace();\r\n        if (this.bumpIf('/>')) {\r\n            // Self closing tag\r\n            return {\r\n                val: {\r\n                    type: TYPE.literal,\r\n                    value: \"<\" + tagName + \"/>\",\r\n                    location: createLocation(startPosition, this.clonePosition()),\r\n                },\r\n                err: null,\r\n            };\r\n        }\r\n        else if (this.bumpIf('>')) {\r\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\r\n            if (childrenResult.err) {\r\n                return childrenResult;\r\n            }\r\n            var children = childrenResult.val;\r\n            // Expecting a close tag\r\n            var endTagStartPosition = this.clonePosition();\r\n            if (this.bumpIf('</')) {\r\n                if (this.isEOF() || !_isAlpha(this.char())) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                var closingTagNameStartPosition = this.clonePosition();\r\n                var closingTagName = this.parseTagName();\r\n                if (tagName !== closingTagName) {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\r\n                }\r\n                this.bumpSpace();\r\n                if (!this.bumpIf('>')) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                return {\r\n                    val: {\r\n                        type: TYPE.tag,\r\n                        value: tagName,\r\n                        children: children,\r\n                        location: createLocation(startPosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            else {\r\n                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\r\n            }\r\n        }\r\n        else {\r\n            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * This method assumes that the caller has peeked ahead for the first tag character.\r\n     */\r\n    Parser.prototype.parseTagName = function () {\r\n        var startOffset = this.offset();\r\n        this.bump(); // the first tag name character\r\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\r\n            this.bump();\r\n        }\r\n        return this.message.slice(startOffset, this.offset());\r\n    };\r\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\r\n        var start = this.clonePosition();\r\n        var value = '';\r\n        while (true) {\r\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\r\n            if (parseQuoteResult) {\r\n                value += parseQuoteResult;\r\n                continue;\r\n            }\r\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\r\n            if (parseUnquotedResult) {\r\n                value += parseUnquotedResult;\r\n                continue;\r\n            }\r\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\r\n            if (parseLeftAngleResult) {\r\n                value += parseLeftAngleResult;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        var location = createLocation(start, this.clonePosition());\r\n        return {\r\n            val: { type: TYPE.literal, value: value, location: location },\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.tryParseLeftAngleBracket = function () {\r\n        if (!this.isEOF() &&\r\n            this.char() === 60 /* `<` */ &&\r\n            (this.ignoreTag ||\r\n                // If at the opening tag or closing tag position, bail.\r\n                !_isAlphaOrSlash(this.peek() || 0))) {\r\n            this.bump(); // `<`\r\n            return '<';\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n     */\r\n    Parser.prototype.tryParseQuote = function (parentArgType) {\r\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\r\n            return null;\r\n        }\r\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\r\n        // Check if is valid escaped character\r\n        switch (this.peek()) {\r\n            case 39 /* `'` */:\r\n                // double quote, should return as a single quote.\r\n                this.bump();\r\n                this.bump();\r\n                return \"'\";\r\n            // '{', '<', '>', '}'\r\n            case 123:\r\n            case 60:\r\n            case 62:\r\n            case 125:\r\n                break;\r\n            case 35: // '#'\r\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\r\n                    break;\r\n                }\r\n                return null;\r\n            default:\r\n                return null;\r\n        }\r\n        this.bump(); // apostrophe\r\n        var codePoints = [this.char()]; // escaped char\r\n        this.bump();\r\n        // read chars until the optional closing apostrophe is found\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch === 39 /* `'` */) {\r\n                if (this.peek() === 39 /* `'` */) {\r\n                    codePoints.push(39);\r\n                    // Bump one more time because we need to skip 2 characters.\r\n                    this.bump();\r\n                }\r\n                else {\r\n                    // Optional closing apostrophe.\r\n                    this.bump();\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                codePoints.push(ch);\r\n            }\r\n            this.bump();\r\n        }\r\n        return fromCodePoint.apply(void 0, codePoints);\r\n    };\r\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var ch = this.char();\r\n        if (ch === 60 /* `<` */ ||\r\n            ch === 123 /* `{` */ ||\r\n            (ch === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\r\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\r\n            return null;\r\n        }\r\n        else {\r\n            this.bump();\r\n            return fromCodePoint(ch);\r\n        }\r\n    };\r\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\r\n        var openingBracePosition = this.clonePosition();\r\n        this.bump(); // `{`\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        if (this.char() === 125 /* `}` */) {\r\n            this.bump();\r\n            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        // argument name\r\n        var value = this.parseIdentifierIfPossible().value;\r\n        if (!value) {\r\n            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        switch (this.char()) {\r\n            // Simple argument: `{name}`\r\n            case 125 /* `}` */: {\r\n                this.bump(); // `}`\r\n                return {\r\n                    val: {\r\n                        type: TYPE.argument,\r\n                        // value does not include the opening and closing braces.\r\n                        value: value,\r\n                        location: createLocation(openingBracePosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            // Argument with options: `{name, format, ...}`\r\n            case 44 /* `,` */: {\r\n                this.bump(); // `,`\r\n                this.bumpSpace();\r\n                if (this.isEOF()) {\r\n                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n                }\r\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * Advance the parser until the end of the identifier, if it is currently on\r\n     * an identifier character. Return an empty string otherwise.\r\n     */\r\n    Parser.prototype.parseIdentifierIfPossible = function () {\r\n        var startingPosition = this.clonePosition();\r\n        var startOffset = this.offset();\r\n        var value = matchIdentifierAtIndex(this.message, startOffset);\r\n        var endOffset = startOffset + value.length;\r\n        this.bumpTo(endOffset);\r\n        var endPosition = this.clonePosition();\r\n        var location = createLocation(startingPosition, endPosition);\r\n        return { value: value, location: location };\r\n    };\r\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\r\n        var _a;\r\n        // Parse this range:\r\n        // {name, type, style}\r\n        //        ^---^\r\n        var typeStartPosition = this.clonePosition();\r\n        var argType = this.parseIdentifierIfPossible().value;\r\n        var typeEndPosition = this.clonePosition();\r\n        switch (argType) {\r\n            case '':\r\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\r\n                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n            case 'number':\r\n            case 'date':\r\n            case 'time': {\r\n                // Parse this range:\r\n                // {name, number, style}\r\n                //              ^-------^\r\n                this.bumpSpace();\r\n                var styleAndLocation = null;\r\n                if (this.bumpIf(',')) {\r\n                    this.bumpSpace();\r\n                    var styleStartPosition = this.clonePosition();\r\n                    var result = this.parseSimpleArgStyleIfPossible();\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    var style = trimEnd(result.val);\r\n                    if (style.length === 0) {\r\n                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\r\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\r\n                // Extract style or skeleton\r\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\r\n                    // Skeleton starts with `::`.\r\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\r\n                    if (argType === 'number') {\r\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\r\n                        if (result.err) {\r\n                            return result;\r\n                        }\r\n                        return {\r\n                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    else {\r\n                        if (skeleton.length === 0) {\r\n                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\r\n                        }\r\n                        var style = {\r\n                            type: SKELETON_TYPE.dateTime,\r\n                            pattern: skeleton,\r\n                            location: styleAndLocation.styleLocation,\r\n                            parsedOptions: this.shouldParseSkeletons\r\n                                ? parseDateTimeSkeleton(skeleton)\r\n                                : {},\r\n                        };\r\n                        var type = argType === 'date' ? TYPE.date : TYPE.time;\r\n                        return {\r\n                            val: { type: type, value: value, location: location_1, style: style },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                }\r\n                // Regular style or no style.\r\n                return {\r\n                    val: {\r\n                        type: argType === 'number'\r\n                            ? TYPE.number\r\n                            : argType === 'date'\r\n                                ? TYPE.date\r\n                                : TYPE.time,\r\n                        value: value,\r\n                        location: location_1,\r\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            case 'plural':\r\n            case 'selectordinal':\r\n            case 'select': {\r\n                // Parse this range:\r\n                // {name, plural, options}\r\n                //              ^---------^\r\n                var typeEndPosition_1 = this.clonePosition();\r\n                this.bumpSpace();\r\n                if (!this.bumpIf(',')) {\r\n                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\r\n                }\r\n                this.bumpSpace();\r\n                // Parse offset:\r\n                // {name, plural, offset:1, options}\r\n                //                ^-----^\r\n                //\r\n                // or the first option:\r\n                //\r\n                // {name, plural, one {...} other {...}}\r\n                //                ^--^\r\n                var identifierAndLocation = this.parseIdentifierIfPossible();\r\n                var pluralOffset = 0;\r\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\r\n                    if (!this.bumpIf(':')) {\r\n                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    this.bumpSpace();\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    // Parse another identifier for option parsing\r\n                    this.bumpSpace();\r\n                    identifierAndLocation = this.parseIdentifierIfPossible();\r\n                    pluralOffset = result.val;\r\n                }\r\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\r\n                if (optionsResult.err) {\r\n                    return optionsResult;\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\r\n                if (argType === 'select') {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.select,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.plural,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            offset: pluralOffset,\r\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n        }\r\n    };\r\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\r\n        // Parse: {value, number, ::currency/GBP }\r\n        //\r\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bump(); // `}`\r\n        return { val: true, err: null };\r\n    };\r\n    /**\r\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n     */\r\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\r\n        var nestedBraces = 0;\r\n        var startPosition = this.clonePosition();\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            switch (ch) {\r\n                case 39 /* `'` */: {\r\n                    // Treat apostrophe as quoting but include it in the style part.\r\n                    // Find the end of the quoted literal text.\r\n                    this.bump();\r\n                    var apostrophePosition = this.clonePosition();\r\n                    if (!this.bumpUntil(\"'\")) {\r\n                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\r\n                    }\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 123 /* `{` */: {\r\n                    nestedBraces += 1;\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 125 /* `}` */: {\r\n                    if (nestedBraces > 0) {\r\n                        nestedBraces -= 1;\r\n                    }\r\n                    else {\r\n                        return {\r\n                            val: this.message.slice(startPosition.offset, this.offset()),\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    this.bump();\r\n                    break;\r\n            }\r\n        }\r\n        return {\r\n            val: this.message.slice(startPosition.offset, this.offset()),\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\r\n        var tokens = [];\r\n        try {\r\n            tokens = parseNumberSkeletonFromString(skeleton);\r\n        }\r\n        catch (e) {\r\n            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\r\n        }\r\n        return {\r\n            val: {\r\n                type: SKELETON_TYPE.number,\r\n                tokens: tokens,\r\n                location: location,\r\n                parsedOptions: this.shouldParseSkeletons\r\n                    ? parseNumberSkeleton(tokens)\r\n                    : {},\r\n            },\r\n            err: null,\r\n        };\r\n    };\r\n    /**\r\n     * @param nesting_level The current nesting level of messages.\r\n     *     This can be positive when parsing message fragment in select or plural argument options.\r\n     * @param parent_arg_type The parent argument's type.\r\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n     *     the argument. It is a by-product of a previous parsing attempt.\r\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n     *     the closing tag boundary.\r\n     */\r\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\r\n        var _a;\r\n        var hasOtherClause = false;\r\n        var options = [];\r\n        var parsedSelectors = new Set();\r\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\r\n        // Parse:\r\n        // one {one apple}\r\n        // ^--^\r\n        while (true) {\r\n            if (selector.length === 0) {\r\n                var startPosition = this.clonePosition();\r\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\r\n                    // Try parse `={number}` selector\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\r\n                    selector = this.message.slice(startPosition.offset, this.offset());\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            // Duplicate selector clauses\r\n            if (parsedSelectors.has(selector)) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\r\n                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\r\n            }\r\n            if (selector === 'other') {\r\n                hasOtherClause = true;\r\n            }\r\n            // Parse:\r\n            // one {one apple}\r\n            //     ^----------^\r\n            this.bumpSpace();\r\n            var openingBracePosition = this.clonePosition();\r\n            if (!this.bumpIf('{')) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\r\n                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\r\n            }\r\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\r\n            if (fragmentResult.err) {\r\n                return fragmentResult;\r\n            }\r\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n            if (argCloseResult.err) {\r\n                return argCloseResult;\r\n            }\r\n            options.push([\r\n                selector,\r\n                {\r\n                    value: fragmentResult.val,\r\n                    location: createLocation(openingBracePosition, this.clonePosition()),\r\n                },\r\n            ]);\r\n            // Keep track of the existing selectors\r\n            parsedSelectors.add(selector);\r\n            // Prep next selector clause.\r\n            this.bumpSpace();\r\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\r\n        }\r\n        if (options.length === 0) {\r\n            return this.error(parentArgType === 'select'\r\n                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\r\n                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        if (this.requiresOtherClause && !hasOtherClause) {\r\n            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        return { val: options, err: null };\r\n    };\r\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\r\n        var sign = 1;\r\n        var startingPosition = this.clonePosition();\r\n        if (this.bumpIf('+')) {\r\n        }\r\n        else if (this.bumpIf('-')) {\r\n            sign = -1;\r\n        }\r\n        var hasDigits = false;\r\n        var decimal = 0;\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\r\n                hasDigits = true;\r\n                decimal = decimal * 10 + (ch - 48);\r\n                this.bump();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        var location = createLocation(startingPosition, this.clonePosition());\r\n        if (!hasDigits) {\r\n            return this.error(expectNumberError, location);\r\n        }\r\n        decimal *= sign;\r\n        if (!isSafeInteger(decimal)) {\r\n            return this.error(invalidNumberError, location);\r\n        }\r\n        return { val: decimal, err: null };\r\n    };\r\n    Parser.prototype.offset = function () {\r\n        return this.position.offset;\r\n    };\r\n    Parser.prototype.isEOF = function () {\r\n        return this.offset() === this.message.length;\r\n    };\r\n    Parser.prototype.clonePosition = function () {\r\n        // This is much faster than `Object.assign` or spread.\r\n        return {\r\n            offset: this.position.offset,\r\n            line: this.position.line,\r\n            column: this.position.column,\r\n        };\r\n    };\r\n    /**\r\n     * Return the code point at the current position of the parser.\r\n     * Throws if the index is out of bound.\r\n     */\r\n    Parser.prototype.char = function () {\r\n        var offset = this.position.offset;\r\n        if (offset >= this.message.length) {\r\n            throw Error('out of bound');\r\n        }\r\n        var code = codePointAt(this.message, offset);\r\n        if (code === undefined) {\r\n            throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\r\n        }\r\n        return code;\r\n    };\r\n    Parser.prototype.error = function (kind, location) {\r\n        return {\r\n            val: null,\r\n            err: {\r\n                kind: kind,\r\n                message: this.message,\r\n                location: location,\r\n            },\r\n        };\r\n    };\r\n    /** Bump the parser to the next UTF-16 code unit. */\r\n    Parser.prototype.bump = function () {\r\n        if (this.isEOF()) {\r\n            return;\r\n        }\r\n        var code = this.char();\r\n        if (code === 10 /* '\\n' */) {\r\n            this.position.line += 1;\r\n            this.position.column = 1;\r\n            this.position.offset += 1;\r\n        }\r\n        else {\r\n            this.position.column += 1;\r\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\r\n            this.position.offset += code < 0x10000 ? 1 : 2;\r\n        }\r\n    };\r\n    /**\r\n     * If the substring starting at the current position of the parser has\r\n     * the given prefix, then bump the parser to the character immediately\r\n     * following the prefix and return true. Otherwise, don't bump the parser\r\n     * and return false.\r\n     */\r\n    Parser.prototype.bumpIf = function (prefix) {\r\n        if (startsWith(this.message, prefix, this.offset())) {\r\n            for (var i = 0; i < prefix.length; i++) {\r\n                this.bump();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Bump the parser until the pattern character is found and return `true`.\r\n     * Otherwise bump to the end of the file and return `false`.\r\n     */\r\n    Parser.prototype.bumpUntil = function (pattern) {\r\n        var currentOffset = this.offset();\r\n        var index = this.message.indexOf(pattern, currentOffset);\r\n        if (index >= 0) {\r\n            this.bumpTo(index);\r\n            return true;\r\n        }\r\n        else {\r\n            this.bumpTo(this.message.length);\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Bump the parser to the target offset.\r\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n     */\r\n    Parser.prototype.bumpTo = function (targetOffset) {\r\n        if (this.offset() > targetOffset) {\r\n            throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\r\n        }\r\n        targetOffset = Math.min(targetOffset, this.message.length);\r\n        while (true) {\r\n            var offset = this.offset();\r\n            if (offset === targetOffset) {\r\n                break;\r\n            }\r\n            if (offset > targetOffset) {\r\n                throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\r\n            }\r\n            this.bump();\r\n            if (this.isEOF()) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\r\n    Parser.prototype.bumpSpace = function () {\r\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\r\n            this.bump();\r\n        }\r\n    };\r\n    /**\r\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n     * If the input has been exhausted, then this returns null.\r\n     */\r\n    Parser.prototype.peek = function () {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var code = this.char();\r\n        var offset = this.offset();\r\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\r\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\r\n    };\r\n    return Parser;\r\n}());\r\nexport { Parser };\r\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\r\nfunction _isAlpha(codepoint) {\r\n    return ((codepoint >= 97 && codepoint <= 122) ||\r\n        (codepoint >= 65 && codepoint <= 90));\r\n}\r\nfunction _isAlphaOrSlash(codepoint) {\r\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\r\n}\r\n/** See `parseTag` function docs. */\r\nfunction _isPotentialElementNameChar(c) {\r\n    return (c === 45 /* '-' */ ||\r\n        c === 46 /* '.' */ ||\r\n        (c >= 48 && c <= 57) /* 0..9 */ ||\r\n        c === 95 /* '_' */ ||\r\n        (c >= 97 && c <= 122) /** a..z */ ||\r\n        (c >= 65 && c <= 90) /* A..Z */ ||\r\n        c == 0xb7 ||\r\n        (c >= 0xc0 && c <= 0xd6) ||\r\n        (c >= 0xd8 && c <= 0xf6) ||\r\n        (c >= 0xf8 && c <= 0x37d) ||\r\n        (c >= 0x37f && c <= 0x1fff) ||\r\n        (c >= 0x200c && c <= 0x200d) ||\r\n        (c >= 0x203f && c <= 0x2040) ||\r\n        (c >= 0x2070 && c <= 0x218f) ||\r\n        (c >= 0x2c00 && c <= 0x2fef) ||\r\n        (c >= 0x3001 && c <= 0xd7ff) ||\r\n        (c >= 0xf900 && c <= 0xfdcf) ||\r\n        (c >= 0xfdf0 && c <= 0xfffd) ||\r\n        (c >= 0x10000 && c <= 0xeffff));\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isWhiteSpace(c) {\r\n    return ((c >= 0x0009 && c <= 0x000d) ||\r\n        c === 0x0020 ||\r\n        c === 0x0085 ||\r\n        (c >= 0x200e && c <= 0x200f) ||\r\n        c === 0x2028 ||\r\n        c === 0x2029);\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isPatternSyntax(c) {\r\n    return ((c >= 0x0021 && c <= 0x0023) ||\r\n        c === 0x0024 ||\r\n        (c >= 0x0025 && c <= 0x0027) ||\r\n        c === 0x0028 ||\r\n        c === 0x0029 ||\r\n        c === 0x002a ||\r\n        c === 0x002b ||\r\n        c === 0x002c ||\r\n        c === 0x002d ||\r\n        (c >= 0x002e && c <= 0x002f) ||\r\n        (c >= 0x003a && c <= 0x003b) ||\r\n        (c >= 0x003c && c <= 0x003e) ||\r\n        (c >= 0x003f && c <= 0x0040) ||\r\n        c === 0x005b ||\r\n        c === 0x005c ||\r\n        c === 0x005d ||\r\n        c === 0x005e ||\r\n        c === 0x0060 ||\r\n        c === 0x007b ||\r\n        c === 0x007c ||\r\n        c === 0x007d ||\r\n        c === 0x007e ||\r\n        c === 0x00a1 ||\r\n        (c >= 0x00a2 && c <= 0x00a5) ||\r\n        c === 0x00a6 ||\r\n        c === 0x00a7 ||\r\n        c === 0x00a9 ||\r\n        c === 0x00ab ||\r\n        c === 0x00ac ||\r\n        c === 0x00ae ||\r\n        c === 0x00b0 ||\r\n        c === 0x00b1 ||\r\n        c === 0x00b6 ||\r\n        c === 0x00bb ||\r\n        c === 0x00bf ||\r\n        c === 0x00d7 ||\r\n        c === 0x00f7 ||\r\n        (c >= 0x2010 && c <= 0x2015) ||\r\n        (c >= 0x2016 && c <= 0x2017) ||\r\n        c === 0x2018 ||\r\n        c === 0x2019 ||\r\n        c === 0x201a ||\r\n        (c >= 0x201b && c <= 0x201c) ||\r\n        c === 0x201d ||\r\n        c === 0x201e ||\r\n        c === 0x201f ||\r\n        (c >= 0x2020 && c <= 0x2027) ||\r\n        (c >= 0x2030 && c <= 0x2038) ||\r\n        c === 0x2039 ||\r\n        c === 0x203a ||\r\n        (c >= 0x203b && c <= 0x203e) ||\r\n        (c >= 0x2041 && c <= 0x2043) ||\r\n        c === 0x2044 ||\r\n        c === 0x2045 ||\r\n        c === 0x2046 ||\r\n        (c >= 0x2047 && c <= 0x2051) ||\r\n        c === 0x2052 ||\r\n        c === 0x2053 ||\r\n        (c >= 0x2055 && c <= 0x205e) ||\r\n        (c >= 0x2190 && c <= 0x2194) ||\r\n        (c >= 0x2195 && c <= 0x2199) ||\r\n        (c >= 0x219a && c <= 0x219b) ||\r\n        (c >= 0x219c && c <= 0x219f) ||\r\n        c === 0x21a0 ||\r\n        (c >= 0x21a1 && c <= 0x21a2) ||\r\n        c === 0x21a3 ||\r\n        (c >= 0x21a4 && c <= 0x21a5) ||\r\n        c === 0x21a6 ||\r\n        (c >= 0x21a7 && c <= 0x21ad) ||\r\n        c === 0x21ae ||\r\n        (c >= 0x21af && c <= 0x21cd) ||\r\n        (c >= 0x21ce && c <= 0x21cf) ||\r\n        (c >= 0x21d0 && c <= 0x21d1) ||\r\n        c === 0x21d2 ||\r\n        c === 0x21d3 ||\r\n        c === 0x21d4 ||\r\n        (c >= 0x21d5 && c <= 0x21f3) ||\r\n        (c >= 0x21f4 && c <= 0x22ff) ||\r\n        (c >= 0x2300 && c <= 0x2307) ||\r\n        c === 0x2308 ||\r\n        c === 0x2309 ||\r\n        c === 0x230a ||\r\n        c === 0x230b ||\r\n        (c >= 0x230c && c <= 0x231f) ||\r\n        (c >= 0x2320 && c <= 0x2321) ||\r\n        (c >= 0x2322 && c <= 0x2328) ||\r\n        c === 0x2329 ||\r\n        c === 0x232a ||\r\n        (c >= 0x232b && c <= 0x237b) ||\r\n        c === 0x237c ||\r\n        (c >= 0x237d && c <= 0x239a) ||\r\n        (c >= 0x239b && c <= 0x23b3) ||\r\n        (c >= 0x23b4 && c <= 0x23db) ||\r\n        (c >= 0x23dc && c <= 0x23e1) ||\r\n        (c >= 0x23e2 && c <= 0x2426) ||\r\n        (c >= 0x2427 && c <= 0x243f) ||\r\n        (c >= 0x2440 && c <= 0x244a) ||\r\n        (c >= 0x244b && c <= 0x245f) ||\r\n        (c >= 0x2500 && c <= 0x25b6) ||\r\n        c === 0x25b7 ||\r\n        (c >= 0x25b8 && c <= 0x25c0) ||\r\n        c === 0x25c1 ||\r\n        (c >= 0x25c2 && c <= 0x25f7) ||\r\n        (c >= 0x25f8 && c <= 0x25ff) ||\r\n        (c >= 0x2600 && c <= 0x266e) ||\r\n        c === 0x266f ||\r\n        (c >= 0x2670 && c <= 0x2767) ||\r\n        c === 0x2768 ||\r\n        c === 0x2769 ||\r\n        c === 0x276a ||\r\n        c === 0x276b ||\r\n        c === 0x276c ||\r\n        c === 0x276d ||\r\n        c === 0x276e ||\r\n        c === 0x276f ||\r\n        c === 0x2770 ||\r\n        c === 0x2771 ||\r\n        c === 0x2772 ||\r\n        c === 0x2773 ||\r\n        c === 0x2774 ||\r\n        c === 0x2775 ||\r\n        (c >= 0x2794 && c <= 0x27bf) ||\r\n        (c >= 0x27c0 && c <= 0x27c4) ||\r\n        c === 0x27c5 ||\r\n        c === 0x27c6 ||\r\n        (c >= 0x27c7 && c <= 0x27e5) ||\r\n        c === 0x27e6 ||\r\n        c === 0x27e7 ||\r\n        c === 0x27e8 ||\r\n        c === 0x27e9 ||\r\n        c === 0x27ea ||\r\n        c === 0x27eb ||\r\n        c === 0x27ec ||\r\n        c === 0x27ed ||\r\n        c === 0x27ee ||\r\n        c === 0x27ef ||\r\n        (c >= 0x27f0 && c <= 0x27ff) ||\r\n        (c >= 0x2800 && c <= 0x28ff) ||\r\n        (c >= 0x2900 && c <= 0x2982) ||\r\n        c === 0x2983 ||\r\n        c === 0x2984 ||\r\n        c === 0x2985 ||\r\n        c === 0x2986 ||\r\n        c === 0x2987 ||\r\n        c === 0x2988 ||\r\n        c === 0x2989 ||\r\n        c === 0x298a ||\r\n        c === 0x298b ||\r\n        c === 0x298c ||\r\n        c === 0x298d ||\r\n        c === 0x298e ||\r\n        c === 0x298f ||\r\n        c === 0x2990 ||\r\n        c === 0x2991 ||\r\n        c === 0x2992 ||\r\n        c === 0x2993 ||\r\n        c === 0x2994 ||\r\n        c === 0x2995 ||\r\n        c === 0x2996 ||\r\n        c === 0x2997 ||\r\n        c === 0x2998 ||\r\n        (c >= 0x2999 && c <= 0x29d7) ||\r\n        c === 0x29d8 ||\r\n        c === 0x29d9 ||\r\n        c === 0x29da ||\r\n        c === 0x29db ||\r\n        (c >= 0x29dc && c <= 0x29fb) ||\r\n        c === 0x29fc ||\r\n        c === 0x29fd ||\r\n        (c >= 0x29fe && c <= 0x2aff) ||\r\n        (c >= 0x2b00 && c <= 0x2b2f) ||\r\n        (c >= 0x2b30 && c <= 0x2b44) ||\r\n        (c >= 0x2b45 && c <= 0x2b46) ||\r\n        (c >= 0x2b47 && c <= 0x2b4c) ||\r\n        (c >= 0x2b4d && c <= 0x2b73) ||\r\n        (c >= 0x2b74 && c <= 0x2b75) ||\r\n        (c >= 0x2b76 && c <= 0x2b95) ||\r\n        c === 0x2b96 ||\r\n        (c >= 0x2b97 && c <= 0x2bff) ||\r\n        (c >= 0x2e00 && c <= 0x2e01) ||\r\n        c === 0x2e02 ||\r\n        c === 0x2e03 ||\r\n        c === 0x2e04 ||\r\n        c === 0x2e05 ||\r\n        (c >= 0x2e06 && c <= 0x2e08) ||\r\n        c === 0x2e09 ||\r\n        c === 0x2e0a ||\r\n        c === 0x2e0b ||\r\n        c === 0x2e0c ||\r\n        c === 0x2e0d ||\r\n        (c >= 0x2e0e && c <= 0x2e16) ||\r\n        c === 0x2e17 ||\r\n        (c >= 0x2e18 && c <= 0x2e19) ||\r\n        c === 0x2e1a ||\r\n        c === 0x2e1b ||\r\n        c === 0x2e1c ||\r\n        c === 0x2e1d ||\r\n        (c >= 0x2e1e && c <= 0x2e1f) ||\r\n        c === 0x2e20 ||\r\n        c === 0x2e21 ||\r\n        c === 0x2e22 ||\r\n        c === 0x2e23 ||\r\n        c === 0x2e24 ||\r\n        c === 0x2e25 ||\r\n        c === 0x2e26 ||\r\n        c === 0x2e27 ||\r\n        c === 0x2e28 ||\r\n        c === 0x2e29 ||\r\n        (c >= 0x2e2a && c <= 0x2e2e) ||\r\n        c === 0x2e2f ||\r\n        (c >= 0x2e30 && c <= 0x2e39) ||\r\n        (c >= 0x2e3a && c <= 0x2e3b) ||\r\n        (c >= 0x2e3c && c <= 0x2e3f) ||\r\n        c === 0x2e40 ||\r\n        c === 0x2e41 ||\r\n        c === 0x2e42 ||\r\n        (c >= 0x2e43 && c <= 0x2e4f) ||\r\n        (c >= 0x2e50 && c <= 0x2e51) ||\r\n        c === 0x2e52 ||\r\n        (c >= 0x2e53 && c <= 0x2e7f) ||\r\n        (c >= 0x3001 && c <= 0x3003) ||\r\n        c === 0x3008 ||\r\n        c === 0x3009 ||\r\n        c === 0x300a ||\r\n        c === 0x300b ||\r\n        c === 0x300c ||\r\n        c === 0x300d ||\r\n        c === 0x300e ||\r\n        c === 0x300f ||\r\n        c === 0x3010 ||\r\n        c === 0x3011 ||\r\n        (c >= 0x3012 && c <= 0x3013) ||\r\n        c === 0x3014 ||\r\n        c === 0x3015 ||\r\n        c === 0x3016 ||\r\n        c === 0x3017 ||\r\n        c === 0x3018 ||\r\n        c === 0x3019 ||\r\n        c === 0x301a ||\r\n        c === 0x301b ||\r\n        c === 0x301c ||\r\n        c === 0x301d ||\r\n        (c >= 0x301e && c <= 0x301f) ||\r\n        c === 0x3020 ||\r\n        c === 0x3030 ||\r\n        c === 0xfd3e ||\r\n        c === 0xfd3f ||\r\n        (c >= 0xfe45 && c <= 0xfe46));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}